// Code generated by github.com/spacemeshos/borsh/gen. DO NOT EDIT.

package gen

import (
	"io"

	"github.com/spacemeshos/borsh"
)

func (t *Nested) MarshalBorsh(w io.Writer) error {
	if err := borsh.WriteLength(w, len(t.Bytes)); err != nil {
		return err
	}
	if _, err := w.Write(t.Bytes[:]); err != nil {
		return err
	}
	return nil
}

func (t *Hello) MarshalBorsh(w io.Writer) error {
	if err := borsh.WriteUint32(w, t.Field1); err != nil {
		return err
	}
	if err := borsh.WriteBool(w, t.Field2); err != nil {
		return err
	}
	if t.PtrToSelf == nil {
		if _, err := w.Write([]byte{0}); err != nil {
			return err
		}
	} else {
		if _, err := w.Write([]byte{1}); err != nil {
			return err
		}
		if err := t.PtrToSelf.MarshalBorsh(w); err != nil {
			return err
		}
	}
	if t.PtrToAnother == nil {
		if _, err := w.Write([]byte{0}); err != nil {
			return err
		}
	} else {
		if _, err := w.Write([]byte{1}); err != nil {
			return err
		}
		if err := t.PtrToAnother.MarshalBorsh(w); err != nil {
			return err
		}
	}
	if err := borsh.WriteLength(w, len(t.ByteSlice)); err != nil {
		return err
	}
	if _, err := w.Write(t.ByteSlice[:]); err != nil {
		return err
	}
	if err := borsh.WriteLength(w, len(t.Uint32Slice)); err != nil {
		return err
	}

	for i := range t.Uint32Slice {
		if err := borsh.WriteUint32(w, t.Uint32Slice[i]); err != nil {
			return err
		}
	}
	if _, err := w.Write(t.ByteArray[:]); err != nil {
		return err
	}
	if err := borsh.WriteLength(w, len(t.StructSlice)); err != nil {
		return err
	}

	for i := range t.StructSlice {
		if err := t.StructSlice[i].MarshalBorsh(w); err != nil {
			return err
		}
	}
	if err := borsh.WriteLength(w, len(t.PtrSlie)); err != nil {
		return err
	}

	for i := range t.PtrSlie {
		if t.PtrSlie[i] == nil {
			if _, err := w.Write([]byte{0}); err != nil {
				return err
			}
		} else {
			if _, err := w.Write([]byte{1}); err != nil {
				return err
			}
			if err := t.PtrSlie[i].MarshalBorsh(w); err != nil {
				return err
			}
		}
	}
	if err := borsh.WriteLength(w, len(t.NestedByteSlices)); err != nil {
		return err
	}

	for i := range t.NestedByteSlices {
		if err := borsh.WriteLength(w, len(t.NestedByteSlices[i])); err != nil {
			return err
		}

		for ii := range t.NestedByteSlices[i] {
			if err := borsh.WriteLength(w, len(t.NestedByteSlices[i][ii])); err != nil {
				return err
			}
			if _, err := w.Write(t.NestedByteSlices[i][ii][:]); err != nil {
				return err
			}
		}
	}
	return nil
}
