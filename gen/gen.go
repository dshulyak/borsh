package gen

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"os"
	"reflect"
)

func Generate(pkg string, filepath string, objs ...interface{}) error {
	buf := bytes.NewBuffer(nil)
	ctx := &genContext{Package: pkg, Imported: generateImports(objs...)}

	err := executeTemplate(buf, `// Code generated by github.com/spacemeshos/borsh/gen. DO NOT EDIT.

	package {{ .Package }}
	
	import (
		"io"

		"github.com/spacemeshos/borsh"

		{{ range $pkg, $short := .Imported }}{{ $short }} "{{ $pkg }}"
        {{ end }}
	)
	`, ctx)
	if err != nil {
		return err
	}

	for _, obj := range objs {
		if err := generateType(buf, ctx, obj); err != nil {
			return err
		}
	}
	data := buf.Bytes()
	data, err = format.Source(data)
	if err != nil {
		return fmt.Errorf("can't format: \ndata: %s\n err:%w", buf.Bytes(), err)
	}
	return os.WriteFile(filepath, data, 0o664)
}

func generateType(w io.Writer, gc *genContext, obj interface{}) error {
	typ := reflect.TypeOf(obj)
	tc := &typeContext{Name: typ.Name(), Type: typ}
	if err := marshalMethod(w, tc); err != nil {
		return err
	}
	if err := unmarshalMethod(w, gc, tc); err != nil {
		return err
	}
	return nil
}

type genContext struct {
	Package  string
	Imported map[string]string // full path to shortname
}

type typeContext struct {
	Name     string
	Index    string
	TypeName string
	Type     reflect.Type
}

func marshalMethod(w io.Writer, tc *typeContext) error {
	typ := tc.Type
	if err := executeTemplate(w, marshalStart, tc); err != nil {
		return err
	}
	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		if private(field) {
			continue
		}
		tctx := &typeContext{Name: field.Name, Type: field.Type, Index: "i"}
		if err := marshalField(w, tctx); err != nil {
			return err
		}
	}
	fmt.Fprintln(w, "return nil")
	fmt.Fprintln(w, "}")
	fmt.Fprintln(w)
	return nil
}

func marshalField(w io.Writer, tc *typeContext) error {
	switch tc.Type.Kind() {
	case reflect.Bool:
		if err := executeTemplate(w, marshalBool, tc); err != nil {
			return err
		}
	case reflect.Uint32:
		if err := executeTemplate(w, marshalUint32, tc); err != nil {
			return err
		}
	case reflect.Struct:
		if err := executeTemplate(w, marshalStruct, tc); err != nil {
			return err
		}
	case reflect.Ptr:
		switch tc.Type.Elem().Kind() {
		case reflect.Array:
			return errors.New("ptr to array is not supported")
		case reflect.Slice:
			return errors.New("ptr to slice is not supported")
		}
		if err := executeTemplate(w, marshalPtr, tc); err != nil {
			return err
		}
	case reflect.Slice:
		if err := executeTemplate(w, marshalLength, tc); err != nil {
			return err
		}
		fallthrough
	case reflect.Array:
		elem := tc.Type.Elem()
		if elem.Kind() == reflect.Uint8 {
			if err := executeTemplate(w, marshalBytes, tc); err != nil {
				return err
			}
		} else {
			if err := executeTemplate(w, addLoop, tc); err != nil {
				return err
			}
			if err := marshalField(w, &typeContext{
				Name:  fmt.Sprintf("%s[%s]", tc.Name, tc.Index),
				Type:  elem,
				Index: tc.Index + tc.Index,
			}); err != nil {
				return err
			}
			fmt.Fprintln(w, "}")
		}
	default:
		return fmt.Errorf("type %v is not supported", tc.Type.Kind())
	}
	return nil
}

func unmarshalMethod(w io.Writer, gc *genContext, tc *typeContext) error {
	typ := tc.Type
	if err := executeTemplate(w, unmarshalStart, tc); err != nil {
		return err
	}
	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		if private(field) {
			continue
		}

		tctx := &typeContext{Name: field.Name, Type: field.Type, TypeName: fullTypeName(gc, field.Type), Index: "i"}
		if err := unmarshalField(w, gc, tctx); err != nil {
			return err
		}
	}
	fmt.Fprintln(w, "return nil")
	fmt.Fprintln(w, "}")
	fmt.Fprintln(w)
	return nil
}

func unmarshalField(w io.Writer, gc *genContext, tc *typeContext) error {
	switch tc.Type.Kind() {
	case reflect.Bool:
		if err := executeTemplate(w, unmarshalBool, tc); err != nil {
			return err
		}
	case reflect.Uint32:
		if err := executeTemplate(w, unmarshalUint32, tc); err != nil {
			return err
		}
	case reflect.Struct:
		if err := executeTemplate(w, unmarshalStruct, tc); err != nil {
			return err
		}
	case reflect.Ptr:
		switch tc.Type.Elem().Kind() {
		case reflect.Array:
			return errors.New("ptr to array is not supported")
		case reflect.Slice:
			return errors.New("ptr to slice is not supported")
		}
		if err := executeTemplate(w, unmarshalPtr, tc); err != nil {
			return err
		}
	case reflect.Slice:
		if err := executeTemplate(w, unmarshalLength, tc); err != nil {
			return err
		}
		fallthrough
	case reflect.Array:
		elem := tc.Type.Elem()
		if elem.Kind() == reflect.Uint8 {
			if err := executeTemplate(w, unmarshalBytes, tc); err != nil {
				return err
			}
		} else {
			if err := executeTemplate(w, addLoop, tc); err != nil {
				return err
			}
			if err := unmarshalField(w, gc, &typeContext{
				Name:     fmt.Sprintf("%s[%s]", tc.Name, tc.Index),
				Type:     elem,
				TypeName: fullTypeName(gc, elem),
				Index:    tc.Index + tc.Index,
			}); err != nil {
				return err
			}
			fmt.Fprintln(w, "}")
		}
	default:
		return fmt.Errorf("type %v is not supported", tc.Type.Kind())
	}
	return nil
}

func fullTypeName(gc *genContext, typ reflect.Type) string {
	// typeName := typ.Name()
	// if canonical, exist := gc.Imported[typ.PkgPath()]; exist {
	// 	typeName = fmt.Sprintf("%s.%s", canonical, typeName)
	// }
	return typ.String()
}
